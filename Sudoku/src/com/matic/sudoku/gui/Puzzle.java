/*
* This file is part of SuDonkey, an open-source Sudoku puzzle game generator and solver.
* Copyright (C) 2014 Vedran Matic
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
*
*/

package com.matic.sudoku.gui;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

import com.matic.sudoku.Resources;
import com.matic.sudoku.gui.board.Board;
import com.matic.sudoku.io.FileFormatManager.FormatType;
import com.matic.sudoku.solver.LogicSolver.Grading;


/**
 * This bean keeps track of properties for a puzzle currently entered on the board 
 * @author vedran
 *
 */
public class Puzzle {
	
	public static final String DEFAULT_URL_SOURCE = "https://github.com/veroslav/sudoku-generator-solver-game";
	public static final String DEFAULT_DESCRIPTION = "A puzzle generated by SuDonkey";
	public static final String DEFAULT_AUTHOR = "SuDonkey Software";
	
	private static final String UNSAVED_PUZZLE_NAME = Resources.getTranslation("puzzle.unsaved");
	private static final String DATE_FORMAT = "yyyy-MM-dd";
		
	//The file on the disk where the puzzle resides, or null if not yet saved
	private File fileStorage;
	
	//How long time (in sec) the player spent solving the puzzle
	private long playTime;
		
	private FormatType formatType;
	private String creationSource;
	private String description;
	private Date creationDate;
	private String urlSource;	
	private Grading grading;
	private String comment;
	private String author;
		
	private final Board board;
	private int[] solution;
	private boolean modified;
	private boolean solved;
	
	public Puzzle(final Board board) {
		this.board = board;
		solution = null;
		fileStorage = null;
		modified = false;
		solved = false;
		playTime = 0;
						
		creationDate = new Date(System.currentTimeMillis());
		formatType = FormatType.SADMAN_SUDOKU;
		description = DEFAULT_DESCRIPTION;
		creationSource = DEFAULT_AUTHOR;
		urlSource = DEFAULT_URL_SOURCE;		
		author = DEFAULT_AUTHOR;
		grading = null;
	}	
	
	public boolean isModified() {
		return modified;
	}

	public void setModified(final boolean modified) {
		this.modified = modified;
	}

	public long getPlayTime() {
		return playTime;
	}

	public void setPlayTime(final long playTime) {		
		this.playTime = playTime;
	}

	public FormatType getFormatType() {
		return formatType;
	}

	public void setFormatType(final FormatType formatType) {
		this.formatType = formatType;
	}

	public String getName() {
		return fileStorage == null? UNSAVED_PUZZLE_NAME : fileStorage.getName();
	}
	
	public File getFileStorage() {
		return fileStorage;
	}
	
	public boolean isSaved() {
		return fileStorage != null;
	}

	public void setFileStorage(final File fileStorage) {
		this.fileStorage = fileStorage;
	}

	public String getCreationSource() {
		return creationSource;
	}

	public void setCreationSource(final String creationSource) {
		this.creationSource = creationSource;
	}

	public String getComment() {
		return comment;
	}

	public void setComment(final String comment) {
		this.comment = comment;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(final String description) {
		this.description = description;
	}

	public Grading getGrading() {
		return grading;
	}

	public void setGrading(final Grading grading) {
		this.grading = grading;
	}

	public String getUrlSource() {
		return urlSource;
	}

	public void setUrlSource(final String urlSource) {
		this.urlSource = urlSource;
	}
	
	public Date getCreationDate() {
		return creationDate;
	}
	
	public String getFormattedDate(final Date currentDate) {
		if(currentDate == null) {
			return null;
		}
		
		final SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
		return dateFormat.format(currentDate);
	}

	public void setCreationDate(final Date creationDate) {
		this.creationDate = creationDate;
		
	}

	public void setAuthor(final String author) {
		this.author = author;
	}
	
	public String getAuthor() {
		return author;
	}

	public int[] getSolution() {
		return solution;
	}

	public void setSolution(final int[] solution) {
		this.solution = solution;
		solved = false;
	}
	
	/**
	 * How many incorrect entries are filled on the board
	 * @return
	 */
	public int getIncorrectCount() {
		int solutionIndex = 0;
		int incorrectCount = 0;
		
		for(int i = 0; i < board.unit; ++i) {
			for(int j = 0; j < board.unit; ++j) {
				final int entry = board.getCellValue(i, j);
				if(entry > 0 && entry != solution[solutionIndex]) {
					++incorrectCount;
				}
				++solutionIndex;
			}
		}
		
		return incorrectCount;
	}
	
	/**
	 * Set whether the player has solved the puzzle
	 * @param solved
	 */
	public void setSolved(final boolean solved) {
		this.solved = solved;
	}
	
	/**
	 * Check whether the puzzle has been solved by the player
	 * @return
	 */
	public boolean isSolved() {
		return solved;
	}
	
	/**
	 * Check if the puzzle is solved correctly by the player
	 * @return true if player has solved the puzzle correctly, false otherwise or
	 * if it was already solved prior to this call
	 */
	public boolean checkSolution() {
		if(!solved && (board.getSymbolsFilledCount() == board.cellCount) &&
				getIncorrectCount() == 0) {
			solved = true;
		}
		return solved;
	}
}
